Index: TradingEngineTest2.java
===================================================================
diff --git a/TradingEngineTest2.java b/TradingEngineTest2.java
deleted file mode 100644
--- a/TradingEngineTest2.java	(revision d6429e63f3352d824f4ae9fe783d4713d9e86804)
+++ /dev/null	(revision d6429e63f3352d824f4ae9fe783d4713d9e86804)
@@ -1,291 +0,0 @@
-import java.time.DayOfWeek;
-import java.time.LocalDateTime;
-import java.time.LocalTime;
-import java.util.*;
-
-public class TradingEngineTest2 {
-    private List<Stock> stocks;
-    private Map<Stock, List<Order>> buyOrders;
-    private Map<Stock, List<Order>> sellOrders;
-    private Map<Stock, Integer> lotPool;
-
-
-    public TradingEngineTest2(List<Stock> stocks) {
-        this.stocks = stocks;
-        this.buyOrders = new HashMap<>();
-        this.sellOrders = new HashMap<>();
-        for (Stock stock : stocks) {
-            buyOrders.put(stock, new ArrayList<>());
-            sellOrders.put(stock, new ArrayList<>());
-        }
-        this.lotPool = new HashMap<>();
-        for (Stock stock : stocks) {
-            lotPool.put(stock, 500); // Initialize the lot pool with 500 shares for each stock
-        }
-    }
-
-    public void executeOrder(Order order, Portfolio portfolio) {
-        if (order.getType() == Order.Type.BUY) {
-            if (isWithinInitialTradingPeriod()) {
-                if (stocks.contains(order.getStock())) {
-                    double currentPrice = order.getStock().getPrice();
-                    double expectedBuyingPrice = order.getExpectedBuyingPrice();
-
-                    if (isPriceWithinRange(expectedBuyingPrice, currentPrice, 1)) {
-                        buyOrders.get(order.getStock()).add(order);
-                        tryExecuteBuyOrder(order, portfolio);
-
-                    } else {
-                        System.out.println("The expected buying price is not within the acceptable range.");
-                    }
-                } else {
-                    System.out.println("The stock is not available for trading during the initial trading period.");
-                }
-            } else {
-                autoMatching(portfolio);
-            }
-        } else {
-            sellOrders.get(order.getStock()).add(order);
-            tryExecuteSellOrder(order, portfolio);
-        }
-
-    }
-
-    private boolean isWithinInitialTradingPeriod() {
-        LocalDateTime currentTime = LocalDateTime.now();
-        LocalDateTime endTime = LocalDateTime.of(currentTime.getYear(), currentTime.getMonth(), currentTime.getDayOfMonth(), 0, 0)
-                .plusDays(3); // Add three days to the current date
-        return currentTime.isBefore(endTime);
-    }
-
-    public void replenishLotPoolDaily() {
-        // Check if it's the start of a new trading day
-        if (isStartOfTradingDay()) {
-            // Reset the lot pool shares to 500 for each stock
-            for (Stock stock : stocks) {
-                lotPool.put(stock, 500);
-            }
-            System.out.println("Lot pool replenished for the day.");
-        }
-    }
-
-    private boolean isStartOfTradingDay() {
-        LocalTime marketOpenTime = LocalTime.of(9, 0); // Adjust the market open time according to your needs
-        LocalTime currentTime = LocalTime.now();
-        return currentTime.equals(marketOpenTime);
-    }
-
-    private boolean isPriceWithinRange(double price, double currentPrice, double rangePercentage) { // Execute trades if the price falls within 1% range
-        double range = currentPrice * (rangePercentage / 100);
-        double lowerLimit = currentPrice - range;
-        double upperLimit = currentPrice + range;
-        return price >= lowerLimit && price <= upperLimit;
-    }
-
-    public boolean isWithinTradingHours() { // Check trading hours
-        // Get the current day and time
-        LocalDateTime currentTime = LocalDateTime.now();
-        DayOfWeek currentDay = currentTime.getDayOfWeek();
-        LocalTime currentTimeOfDay = currentTime.toLocalTime();
-
-        // Check if it's a weekday (Monday to Friday) and within regular market hours
-        if (currentDay != DayOfWeek.SATURDAY && currentDay != DayOfWeek.SUNDAY) {
-            LocalTime marketOpenTime1 = LocalTime.of(9, 0);
-            LocalTime marketCloseTime1 = LocalTime.of(12, 30);
-            LocalTime marketOpenTime2 = LocalTime.of(14, 30);
-            LocalTime marketCloseTime2 = LocalTime.of(17, 0);
-            return (currentTimeOfDay.isAfter(marketOpenTime1) && currentTimeOfDay.isBefore(marketCloseTime1))
-                    || (currentTimeOfDay.isAfter(marketOpenTime2) && currentTimeOfDay.isBefore(marketCloseTime2));
-        }
-        return false;
-    }
-
-    private void tryExecuteBuyOrder(Order order, Portfolio portfolio) { //need ziji remove from sellOrders/lotpool after this method is called
-        List<Order> orders = buyOrders.get(order.getStock()); //loop buy order,if enough money, add buy order into portfolio
-        double price = order.getStock().getPrice();
-        int shares = order.getShares();
-        double totalPrice = price * shares;
-
-        if (order.getPrice() >= price && portfolio.getAccBalance() >= totalPrice) {
-            double temp = portfolio.getAccBalance();
-            temp -= totalPrice;
-            portfolio.setAccBalance(temp);
-            portfolio.addStock(order.getStock(), shares);
-            orders.remove(order);
-            System.out.println("Buy order executed successfully.");
-        } else {
-            System.out.println("Not enough money");
-        }
-    }
-
-    public void cancelBuyOrder(String stockSymbol) {
-        Stock stock = getStockBySymbol(stockSymbol);
-        List<Order> orders = buyOrders.get(stock);
-        if (!orders.isEmpty()) {
-            System.out.println("Choose the cancel option: ");
-            System.out.println("1. Cancel based on longest time");
-            System.out.println("2. Cancel based on highest price");
-
-            Scanner scanner = new Scanner(System.in);
-            int choice = scanner.nextInt();
-            scanner.nextLine(); // Consume the newline character
-
-            switch (choice) {
-                case 1:
-                    Order orderToCancelByTime = getOrderWithLongestTime(orders);
-                    orders.remove(orderToCancelByTime);
-                    System.out.println("Buy order canceled based on longest time successfully.");
-                    break;
-                case 2:
-                    Order orderToCancelByPrice = getOrderWithHighestPrice(orders);
-                    orders.remove(orderToCancelByPrice);
-                    System.out.println("Buy order canceled based on highest price successfully.");
-                    break;
-                default:
-                    System.out.println("Invalid choice. Buy order cancellation canceled.");
-                    break;
-            }
-        } else {
-            System.out.println("No buy orders available for the specified stock.");
-        }
-    }
-
-    private Order getOrderWithLongestTime(List<Order> orders) {
-        Order orderWithLongestTime = null;
-        LocalDateTime longestTime = LocalDateTime.MIN;
-
-        for (Order order : orders) {
-            LocalDateTime orderTime = order.getTimestamp();
-            if (orderTime.compareTo(longestTime) > 0) {
-                longestTime = orderTime;
-                orderWithLongestTime = order;
-            }
-        }
-
-        return orderWithLongestTime;
-    }
-
-    private Order getOrderWithHighestPrice(List<Order> orders) {
-        Order orderWithHighestPrice = null;
-        double highestPrice = Double.MIN_VALUE;
-
-        for (Order order : orders) {
-            double orderPrice = order.getPrice();
-            if (orderPrice > highestPrice) {
-                highestPrice = orderPrice;
-                orderWithHighestPrice = order;
-            }
-        }
-
-        return orderWithHighestPrice;
-    }
-
-    public void closeMarket(Portfolio portfolio, double accountBalance) {
-        if (isWithinTradingHours()) {
-            System.out.println("The market is still open. Cannot close the market now.");
-            return;
-        }
-
-        // Check if the account balance is non-negative
-        if (accountBalance >= 0) {
-            System.out.println("Market closed successfully.");
-            // Perform any necessary actions to finalize the market closing
-
-            // Reset the buy and sell orders
-            buyOrders.clear();
-            sellOrders.clear();
-            for (Stock stock : stocks) {
-                buyOrders.put(stock, new ArrayList<>());
-                sellOrders.put(stock, new ArrayList<>());
-            }
-        } else {
-            System.out.println("Cannot close the market. Account balance is negative.");
-        }
-    }
-
-    public void displaySuggestedPrice(String stockSymbol, int quantity) {
-        Stock stock;
-
-        for (Stock s : stocks) {
-            if (s.getSymbol().equalsIgnoreCase(stockSymbol)) {
-                stock = s;
-                if (stock != null) {
-                    double currentPrice = stock.getPrice() * quantity;
-                    double lowerLimit = currentPrice * 0.99; // 1% below the current price
-                    double upperLimit = currentPrice * 1.01;
-
-                    System.out.println("Suggested price range for " + stockSymbol + ": " + lowerLimit + " - " + upperLimit);
-                } else {
-                    System.out.println("Stock with symbol " + stockSymbol + " not found.");
-                }
-            }
-        }
-    }
-    public void displaySellOrders() {
-        System.out.println("Sell Orders:");
-
-        for (Stock stock : stocks) {
-            List<Order> sellOrderList = sellOrders.get(stock);
-            if (!sellOrderList.isEmpty()) {
-                System.out.println("Stock: " + stock.getSymbol());
-                for (Order order : sellOrderList) {
-                    System.out.println("  Price: " + order.getPrice());
-                    System.out.println("  Shares: " + order.getShares());
-                    System.out.println("  Timestamp: " + order.getTimestamp());
-                    System.out.println("------------------------");
-                }
-            }
-        }
-    }
-
-
-    public Stock getStockBySymbol(String symbol) {
-        for (Stock stock : stocks) {
-            if (stock.getSymbol().equalsIgnoreCase(symbol)) {
-                return stock;
-            }
-        }
-        return null; // Stock with the specified symbol not found
-    }
-
-    private void tryExecuteSellOrder(Order order, Portfolio portfolio) {
-        List<Order> orders = sellOrders.get(order.getStock());
-        double price = order.getStock().getPrice();
-        int shares = order.getShares();
-        double totalPrice = price * shares;
-
-            double temp = portfolio.getAccBalance();
-            temp += totalPrice;
-            portfolio.setAccBalance(temp);
-            portfolio.removeStock(order.getStock(), shares);
-            orders.remove(order);
-            System.out.println("Sell order executed successfully.");
-        }
-    public void autoMatching(Portfolio portfolio) {
-        for (Stock stock : stocks) {
-            List<Order> buyOrderList = buyOrders.get(stock);
-            List<Order> sellOrderList = sellOrders.get(stock);
-
-            // Iterate over the buy orders
-            for (Order buyOrder : buyOrderList) {
-                // Check if the buy order symbol and price match with any sell order
-                for (Order sellOrder : sellOrderList) {
-                    if (isInSellOrder(buyOrder, sellOrder)) {
-                        tryExecuteBuyOrder(buyOrder, portfolio);
-                        sellOrders.remove(stock);
-                    }
-                    // Check if the buy order symbol and price match with the lot pool
-                    else if ((!isInSellOrder(buyOrder, sellOrder)) && lotPool.containsKey(buyOrder.getStock()) && lotPool.containsValue(buyOrder.getShares())) {
-                        tryExecuteBuyOrder(buyOrder, portfolio);
-                        lotPool.remove(buyOrder.getStock(), buyOrder.getShares());
-                    } else {
-                        System.out.println("Stock is not available");
-                    }
-                }
-            }
-        }
-    }
-        private boolean isInSellOrder(Order buyOrder, Order sellOrder){
-            return buyOrder.getStock().getSymbol().equals(sellOrder.getStock().getSymbol()) && buyOrder.getPrice() == sellOrder.getPrice();
-        }
-            }
Index: Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Main.java b/Main.java
new file mode 100644
--- /dev/null	(date 1684900650674)
+++ b/Main.java	(date 1684900650674)
@@ -0,0 +1,5 @@
+public class Main {
+    public static void main(String[] args) {
+
+    }
+}
Index: NotificationService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Timer;\r\nimport java.util.TimerTask;\r\n\r\n// Create a Notification class\r\nclass Notification {\r\n    private String userId;\r\n    private double pnl;\r\n    private boolean enteredPosition;\r\n    private boolean exitedPosition;\r\n\r\n    public Notification(String userId) {\r\n        this.userId = userId;\r\n    }\r\n\r\n    public String getUserId() {\r\n        return userId;\r\n    }\r\n\r\n    public double getPnl() {\r\n        return pnl;\r\n    }\r\n\r\n    public void setPnl(double pnl) {\r\n        this.pnl = pnl;\r\n    }\r\n\r\n    public boolean hasEnteredPosition() {\r\n        return enteredPosition;\r\n    }\r\n\r\n    public void setEnteredPosition(boolean enteredPosition) {\r\n        this.enteredPosition = enteredPosition;\r\n    }\r\n\r\n    public boolean hasExitedPosition() {\r\n        return exitedPosition;\r\n    }\r\n\r\n    public void setExitedPosition(boolean exitedPosition) {\r\n        this.exitedPosition = exitedPosition;\r\n    }\r\n}\r\n\r\n// Utilize a third-party library like JavaMail for sending notifications\r\nclass EmailService {\r\n    public void sendNotification(String userId, String message) {\r\n        // Logic for sending email using JavaMail library\r\n        System.out.println(\"Sending email notification to user \" + userId + \": \" + message);\r\n    }\r\n}\r\n\r\n// Implement methods for handling user settings\r\nclass UserSettings {\r\n    private double pnlThreshold;\r\n    private boolean enableNotifications;\r\n\r\n    public double getPnlThreshold() {\r\n        return pnlThreshold;\r\n    }\r\n\r\n    public void setPnlThreshold(double pnlThreshold) {\r\n        this.pnlThreshold = pnlThreshold;\r\n    }\r\n\r\n    public boolean isEnableNotifications() {\r\n        return enableNotifications;\r\n    }\r\n\r\n    public void setEnableNotifications(boolean enableNotifications) {\r\n        this.enableNotifications = enableNotifications;\r\n    }\r\n}\r\n\r\n// Use a timer or scheduling framework to periodically check for threshold crossing\r\nclass NotificationScheduler {\r\n    private List<Notification> notifications;\r\n    private EmailService emailService;\r\n    private UserSettings userSettings;\r\n\r\n    public NotificationScheduler() {\r\n        this.notifications = new ArrayList<>();\r\n        this.emailService = new EmailService();\r\n        this.userSettings = new UserSettings();\r\n    }\r\n\r\n    public void startScheduler() {\r\n        Timer timer = new Timer();\r\n        timer.schedule(new TimerTask() {\r\n            @Override\r\n            public void run() {\r\n                checkThresholds();\r\n            }\r\n        }, 0, 1000); \r\n    }\r\n\r\n    private void checkThresholds() {\r\n        for (Notification notification : notifications) {\r\n            if (notification.hasEnteredPosition() && notification.getPnl() > userSettings.getPnlThreshold()) {\r\n                sendNotification(notification, \"Your P&L crossed the threshold: \" + notification.getPnl());\r\n            } else if (notification.hasExitedPosition() && notification.getPnl() < userSettings.getPnlThreshold()) {\r\n                sendNotification(notification, \"Your P&L dropped below the threshold: \" + notification.getPnl());\r\n            }\r\n        }\r\n    }\r\n\r\n    private void sendNotification(Notification notification, String message) {\r\n        if (userSettings.isEnableNotifications()) {\r\n            emailService.sendNotification(notification.getUserId(), message);\r\n        }\r\n    }\r\n\r\n    // Additional methods for managing user settings and notifications\r\n    public void addUserNotification(Notification notification) {\r\n        notifications.add(notification);\r\n    }\r\n\r\n    public void removeUserNotification(Notification notification) {\r\n        notifications.remove(notification);\r\n    }\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NotificationService.java b/NotificationService.java
--- a/NotificationService.java	(revision d6429e63f3352d824f4ae9fe783d4713d9e86804)
+++ b/NotificationService.java	(date 1684899867020)
@@ -92,7 +92,7 @@
             public void run() {
                 checkThresholds();
             }
-        }, 0, 1000); 
+        }, 0, 1000);
     }
 
     private void checkThresholds() {
@@ -119,4 +119,5 @@
     public void removeUserNotification(Notification notification) {
         notifications.remove(notification);
     }
+}
 
Index: Report.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Report.java b/Report.java
new file mode 100644
--- /dev/null	(date 1684899867028)
+++ b/Report.java	(date 1684899867028)
@@ -0,0 +1,3 @@
+public class Report {
+
+}
Index: TradingEngine.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.time.DayOfWeek;\r\nimport java.time.LocalDateTime;\r\nimport java.time.LocalTime;\r\nimport java.util.*;\r\n\r\npublic class TradingEngine {\r\n    private List<Stock> stocks;\r\n    private Map<Stock, List<Order>> buyOrders;\r\n    private Map<Stock, List<Order>> sellOrders;\r\n    private Map<Stock, Integer> lotPool;\r\n\r\n\r\n    public TradingEngine(List<Stock> stocks) {\r\n        this.stocks = stocks;\r\n        this.buyOrders = new HashMap<>();\r\n        this.sellOrders = new HashMap<>();\r\n        for (Stock stock : stocks) {\r\n            buyOrders.put(stock, new ArrayList<>());\r\n            sellOrders.put(stock, new ArrayList<>());\r\n        }\r\n        this.lotPool = new HashMap<>();\r\n        for (Stock stock : stocks) {\r\n            lotPool.put(stock, 500); // Initialize the lotpool with 500 shares for each stock\r\n        }\r\n    }\r\n\r\n    public void executeOrder(Order order, Portfolio portfolio) {\r\n        if (order.getType() == Order.Type.BUY) {\r\n            if (isWithinInitialTradingPeriod()) {\r\n                if (stocks.contains(order.getStock())) {\r\n                    double currentPrice = order.getStock().getPrice();\r\n                    double expectedBuyingPrice = order.getExpectedBuyingPrice();\r\n\r\n                    if (isPriceWithinRange(expectedBuyingPrice, currentPrice, 1)) {\r\n                        buyOrders.get(order.getStock()).add(order);\r\n                        tryExecuteBuyOrder(order, portfolio);\r\n\r\n                    } else {\r\n                        System.out.println(\"The expected buying price is not within the acceptable range.\");\r\n                    }\r\n                } else {\r\n                    System.out.println(\"The stock is not available for trading during the initial trading period.\");\r\n                }\r\n            } else {\r\n                autoMatching(portfolio);\r\n            }\r\n        } else {\r\n            sellOrders.get(order.getStock()).add(order);\r\n            tryExecuteSellOrder(order, portfolio);\r\n        }\r\n\r\n    }\r\n\r\n    private boolean isWithinInitialTradingPeriod() {\r\n        LocalDateTime currentTime = LocalDateTime.now();\r\n        LocalDateTime endTime = LocalDateTime.of(currentTime.getYear(), currentTime.getMonth(), currentTime.getDayOfMonth(), 0, 0)\r\n                .plusDays(3); // Add 3 days to the current date\r\n        return currentTime.isBefore(endTime);\r\n    }\r\n\r\n    public void replenishLotPoolDaily() {\r\n        // Check if it's the start of a new trading day\r\n        if (isStartOfTradingDay()) {\r\n            // Reset the lotpool shares to 500 for each stock\r\n            for (Stock stock : stocks) {\r\n                lotPool.put(stock, 500);\r\n            }\r\n            System.out.println(\"Lot pool replenished for the day.\");\r\n        }\r\n    }\r\n\r\n    private boolean isStartOfTradingDay() {\r\n        LocalTime marketOpenTime = LocalTime.of(9, 0); // Adjust the market open time according to your needs\r\n        LocalTime currentTime = LocalTime.now();\r\n        return currentTime.equals(marketOpenTime);\r\n    }\r\n\r\n    private boolean isPriceWithinRange(double price, double currentPrice, double rangePercentage) { // Execute trades if the price falls within 1% range\r\n        double range = currentPrice * (rangePercentage / 100);\r\n        double lowerLimit = currentPrice - range;\r\n        double upperLimit = currentPrice + range;\r\n        return price >= lowerLimit && price <= upperLimit;\r\n    }\r\n\r\n    public boolean isWithinTradingHours() { // Check trading hours\r\n        // Get the current day and time\r\n        LocalDateTime currentTime = LocalDateTime.now();\r\n        DayOfWeek currentDay = currentTime.getDayOfWeek();\r\n        LocalTime currentTimeOfDay = currentTime.toLocalTime();\r\n\r\n        // Check if it's a weekday (Monday to Friday) and within regular market hours\r\n        if (currentDay != DayOfWeek.SATURDAY && currentDay != DayOfWeek.SUNDAY) {\r\n            LocalTime marketOpenTime1 = LocalTime.of(9, 0);\r\n            LocalTime marketCloseTime1 = LocalTime.of(12, 30);\r\n            LocalTime marketOpenTime2 = LocalTime.of(14, 30);\r\n            LocalTime marketCloseTime2 = LocalTime.of(17, 0);\r\n            return (currentTimeOfDay.isAfter(marketOpenTime1) && currentTimeOfDay.isBefore(marketCloseTime1))\r\n                    || (currentTimeOfDay.isAfter(marketOpenTime2) && currentTimeOfDay.isBefore(marketCloseTime2));\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private void tryExecuteBuyOrder(Order order, Portfolio portfolio) { //need ziji remove from sellOrders/lotpool after this method is called\r\n        List<Order> orders = buyOrders.get(order.getStock()); //loop buy order,if enough money, add buy order into portfolio\r\n        double price = order.getStock().getPrice();\r\n        int shares = order.getShares();\r\n        double totalPrice = price * shares;\r\n\r\n        if (order.getPrice() >= price && portfolio.getAccBalance() >= totalPrice) {\r\n            double temp = portfolio.getAccBalance();\r\n            temp -= totalPrice;\r\n            portfolio.setAccBalance(temp);\r\n            portfolio.addStock(order.getStock(), shares);\r\n            orders.remove(order);\r\n            System.out.println(\"Buy order executed successfully.\");\r\n        } else {\r\n            System.out.println(\"Not enough money\");\r\n        }\r\n    }\r\n\r\n    public void cancelBuyOrder(String stockSymbol) {\r\n        Stock stock = getStockBySymbol(stockSymbol);\r\n        List<Order> orders = buyOrders.get(stock);\r\n        if (!orders.isEmpty()) {\r\n            System.out.println(\"Choose the cancel option: \");\r\n            System.out.println(\"1. Cancel based on longest time\");\r\n            System.out.println(\"2. Cancel based on highest price\");\r\n\r\n            Scanner scanner = new Scanner(System.in);\r\n            int choice = scanner.nextInt();\r\n            scanner.nextLine(); // Consume the newline character\r\n\r\n            switch (choice) {\r\n                case 1:\r\n                    Order orderToCancelByTime = getOrderWithLongestTime(orders);\r\n                    orders.remove(orderToCancelByTime);\r\n                    System.out.println(\"Buy order canceled based on longest time successfully.\");\r\n                    break;\r\n                case 2:\r\n                    Order orderToCancelByPrice = getOrderWithHighestPrice(orders);\r\n                    orders.remove(orderToCancelByPrice);\r\n                    System.out.println(\"Buy order canceled based on highest price successfully.\");\r\n                    break;\r\n                default:\r\n                    System.out.println(\"Invalid choice. Buy order cancellation canceled.\");\r\n                    break;\r\n            }\r\n        } else {\r\n            System.out.println(\"No buy orders available for the specified stock.\");\r\n        }\r\n    }\r\n\r\n    private Order getOrderWithLongestTime(List<Order> orders) {\r\n        Order orderWithLongestTime = null;\r\n        LocalDateTime longestTime = LocalDateTime.MIN;\r\n\r\n        for (Order order : orders) {\r\n            LocalDateTime orderTime = order.getTimestamp();\r\n            if (orderTime.compareTo(longestTime) > 0) {\r\n                longestTime = orderTime;\r\n                orderWithLongestTime = order;\r\n            }\r\n        }\r\n\r\n        return orderWithLongestTime;\r\n    }\r\n\r\n    private Order getOrderWithHighestPrice(List<Order> orders) {\r\n        Order orderWithHighestPrice = null;\r\n        double highestPrice = Double.MIN_VALUE;\r\n\r\n        for (Order order : orders) {\r\n            double orderPrice = order.getPrice();\r\n            if (orderPrice > highestPrice) {\r\n                highestPrice = orderPrice;\r\n                orderWithHighestPrice = order;\r\n            }\r\n        }\r\n\r\n        return orderWithHighestPrice;\r\n    }\r\n\r\n    public void closeMarket(Portfolio portfolio, double accountBalance) {\r\n        if (isWithinTradingHours()) {\r\n            System.out.println(\"The market is still open. Cannot close the market now.\");\r\n            return;\r\n        }\r\n\r\n        // Check if the account balance is non-negative\r\n        if (accountBalance >= 0) {\r\n            System.out.println(\"Market closed successfully.\");\r\n            // Perform any necessary actions to finalize the market closing\r\n\r\n            // Reset the buy and sell orders\r\n            buyOrders.clear();\r\n            sellOrders.clear();\r\n            for (Stock stock : stocks) {\r\n                buyOrders.put(stock, new ArrayList<>());\r\n                sellOrders.put(stock, new ArrayList<>());\r\n            }\r\n        } else {\r\n            System.out.println(\"Cannot close the market. Account balance is negative.\");\r\n        }\r\n    }\r\n\r\n    public void displaySuggestedPrice(String stockSymbol, int quantity) {\r\n        Stock stock;\r\n\r\n        for (Stock s : stocks) {\r\n            if (s.getSymbol().equalsIgnoreCase(stockSymbol)) {\r\n                stock = s;\r\n                if (stock != null) {\r\n                    double currentPrice = stock.getPrice() * quantity;\r\n                    double lowerLimit = currentPrice * 0.99; // 1% below the current price\r\n                    double upperLimit = currentPrice * 1.01;\r\n\r\n                    System.out.println(\"Suggested price range for \" + stockSymbol + \": \" + lowerLimit + \" - \" + upperLimit);\r\n                } else {\r\n                    System.out.println(\"Stock with symbol \" + stockSymbol + \" not found.\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n    public void displaySellOrders() {\r\n        System.out.println(\"Sell Orders:\");\r\n\r\n        for (Stock stock : stocks) {\r\n            List<Order> sellOrderList = sellOrders.get(stock);\r\n            if (!sellOrderList.isEmpty()) {\r\n                System.out.println(\"Stock: \" + stock.getSymbol());\r\n                for (Order order : sellOrderList) {\r\n                    System.out.println(\"  Price: \" + order.getPrice());\r\n                    System.out.println(\"  Shares: \" + order.getShares());\r\n                    System.out.println(\"  Timestamp: \" + order.getTimestamp());\r\n                    System.out.println(\"------------------------\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public Stock getStockBySymbol(String symbol) {\r\n        for (Stock stock : stocks) {\r\n            if (stock.getSymbol().equalsIgnoreCase(symbol)) {\r\n                return stock;\r\n            }\r\n        }\r\n        return null; // Stock with the specified symbol not found\r\n    }\r\n\r\n    private void tryExecuteSellOrder(Order order, Portfolio portfolio) {\r\n        List<Order> orders = sellOrders.get(order.getStock());\r\n        double price = order.getStock().getPrice();\r\n        int shares = order.getShares();\r\n        double totalPrice = price * shares;\r\n\r\n        double temp = portfolio.getAccBalance();\r\n        temp += totalPrice;\r\n        portfolio.setAccBalance(temp);\r\n        portfolio.removeStock(order.getStock(), shares);\r\n        orders.remove(order);\r\n        System.out.println(\"Sell order executed successfully.\");\r\n    }\r\n    public void autoMatching(Portfolio portfolio) {\r\n        for (Stock stock : stocks) {\r\n            List<Order> buyOrderList = buyOrders.get(stock);\r\n            List<Order> sellOrderList = sellOrders.get(stock);\r\n\r\n            // Iterate over the buy orders\r\n            for (Order buyOrder : buyOrderList) {\r\n                // Check if the buy order symbol and price match with any sell order\r\n                for (Order sellOrder : sellOrderList) {\r\n                    if (isInSellOrder(buyOrder, sellOrder)) {\r\n                        tryExecuteBuyOrder(buyOrder, portfolio);\r\n                        sellOrders.remove(stock);\r\n                    }\r\n                    // Check if the buy order symbol and price match with the lot pool\r\n                    else if ((!isInSellOrder(buyOrder, sellOrder)) && lotPool.containsKey(buyOrder.getStock()) && lotPool.containsValue(buyOrder.getShares())) {\r\n                        tryExecuteBuyOrder(buyOrder, portfolio);\r\n                        lotPool.remove(buyOrder.getStock(), buyOrder.getShares());\r\n                    } else {\r\n                        System.out.println(\"Stock is not available\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private boolean isInSellOrder(Order buyOrder, Order sellOrder){\r\n        return buyOrder.getStock().getSymbol().equals(sellOrder.getStock().getSymbol()) && buyOrder.getPrice() == sellOrder.getPrice();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TradingEngine.java b/TradingEngine.java
--- a/TradingEngine.java	(revision d6429e63f3352d824f4ae9fe783d4713d9e86804)
+++ b/TradingEngine.java	(date 1684901437091)
@@ -1,3 +1,4 @@
+import java.io.IOException;
 import java.time.DayOfWeek;
 import java.time.LocalDateTime;
 import java.time.LocalTime;
@@ -8,10 +9,11 @@
     private Map<Stock, List<Order>> buyOrders;
     private Map<Stock, List<Order>> sellOrders;
     private Map<Stock, Integer> lotPool;
+    API api = new API();
 
 
     public TradingEngine(List<Stock> stocks) {
-        this.stocks = stocks;
+        //this.stocks = api.getStock();
         this.buyOrders = new HashMap<>();
         this.sellOrders = new HashMap<>();
         for (Stock stock : stocks) {
@@ -24,17 +26,16 @@
         }
     }
 
-    public void executeOrder(Order order, Portfolio portfolio) {
+    public void executeOrder(Order order, Portfolio portfolio) throws IOException {
         if (order.getType() == Order.Type.BUY) {
             if (isWithinInitialTradingPeriod()) {
                 if (stocks.contains(order.getStock())) {
-                    double currentPrice = order.getStock().getPrice();
+                    double currentPrice = api.getRealTimePrice(order.getStock().getSymbol());
                     double expectedBuyingPrice = order.getExpectedBuyingPrice();
 
                     if (isPriceWithinRange(expectedBuyingPrice, currentPrice, 1)) {
                         buyOrders.get(order.getStock()).add(order);
                         tryExecuteBuyOrder(order, portfolio);
-
                     } else {
                         System.out.println("The expected buying price is not within the acceptable range.");
                     }
@@ -48,7 +49,6 @@
             sellOrders.get(order.getStock()).add(order);
             tryExecuteSellOrder(order, portfolio);
         }
-
     }
 
     private boolean isWithinInitialTradingPeriod() {
@@ -102,7 +102,7 @@
 
     private void tryExecuteBuyOrder(Order order, Portfolio portfolio) { //need ziji remove from sellOrders/lotpool after this method is called
         List<Order> orders = buyOrders.get(order.getStock()); //loop buy order,if enough money, add buy order into portfolio
-        double price = order.getStock().getPrice();
+        double price = order.getExpectedBuyingPrice();
         int shares = order.getShares();
         double totalPrice = price * shares;
 
@@ -203,14 +203,14 @@
         }
     }
 
-    public void displaySuggestedPrice(String stockSymbol, int quantity) {
+    public void displaySuggestedPrice(String stockSymbol, int quantity) throws IOException {
         Stock stock;
 
         for (Stock s : stocks) {
             if (s.getSymbol().equalsIgnoreCase(stockSymbol)) {
                 stock = s;
                 if (stock != null) {
-                    double currentPrice = stock.getPrice() * quantity;
+                    double currentPrice = api.getRealTimePrice(stockSymbol) * quantity;
                     double lowerLimit = currentPrice * 0.99; // 1% below the current price
                     double upperLimit = currentPrice * 1.01;
 
@@ -221,6 +221,7 @@
             }
         }
     }
+
     public void displaySellOrders() {
         System.out.println("Sell Orders:");
 
@@ -250,7 +251,7 @@
 
     private void tryExecuteSellOrder(Order order, Portfolio portfolio) {
         List<Order> orders = sellOrders.get(order.getStock());
-        double price = order.getStock().getPrice();
+        double price = order.getExpectedSellingPrice();
         int shares = order.getShares();
         double totalPrice = price * shares;
 
@@ -261,6 +262,7 @@
         orders.remove(order);
         System.out.println("Sell order executed successfully.");
     }
+
     public void autoMatching(Portfolio portfolio) {
         for (Stock stock : stocks) {
             List<Order> buyOrderList = buyOrders.get(stock);
@@ -285,7 +287,8 @@
             }
         }
     }
-    private boolean isInSellOrder(Order buyOrder, Order sellOrder){
+
+    private boolean isInSellOrder(Order buyOrder, Order sellOrder) {
         return buyOrder.getStock().getSymbol().equals(sellOrder.getStock().getSymbol()) && buyOrder.getPrice() == sellOrder.getPrice();
     }
 }
Index: Stock.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>public class Stock {\r\n    private String symbol;\r\n    private String name;\r\n    private double price;\r\n\r\n    public Stock(String symbol, String name, double price) {\r\n        this.symbol = symbol;\r\n        this.name = name;\r\n        this.price = price;\r\n    }\r\n\r\n    public String getSymbol() {\r\n        return symbol;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public double getPrice() {\r\n        return price;\r\n    }\r\n\r\n    public void setPrice(double price) {\r\n        this.price = price;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Stock.java b/Stock.java
--- a/Stock.java	(revision d6429e63f3352d824f4ae9fe783d4713d9e86804)
+++ b/Stock.java	(date 1684900650690)
@@ -3,10 +3,10 @@
     private String name;
     private double price;
 
-    public Stock(String symbol, String name, double price) {
+    public Stock(String symbol, String name) {
         this.symbol = symbol;
         this.name = name;
-        this.price = price;
+
     }
 
     public String getSymbol() {
@@ -17,10 +17,6 @@
         return name;
     }
 
-    public double getPrice() {
-        return price;
-    }
-
     public void setPrice(double price) {
         this.price = price;
     }
Index: Leaderboard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.List;\r\n\r\nclass UserScore {\r\n        private String name;\r\n        private int marks;\r\n\r\n        public UserScore(String name, int marks) {\r\n            this.name = name;\r\n            this.marks = marks;\r\n        }\r\n\r\n        public String getName() {\r\n            return name;\r\n        }\r\n\r\n        public int getMarks() {\r\n            return marks;\r\n        }\r\npublic class Leaderboard {\r\n    public static void main(String[] args) {\r\n        // Retrieve users' names and marks from the dashboard\r\n        List<UserScore> dashboardData = retrieveDataFromDashboard();\r\n\r\n        // Sort the data based on marks in descending order\r\n        Collections.sort(dashboardData, Comparator.comparingInt(UserScore::getMarks).reversed());\r\n\r\n        // Extract the top ten users\r\n        List<UserScore> topTenUsers = dashboardData.subList(0, Math.min(dashboardData.size(), 10));\r\n\r\n        // Display the leaderboard\r\n        System.out.println(\"Rank | User         | Marks\");\r\n        System.out.println(\"-----|--------------|-------\");\r\n        // Add condition if user is disqualified then score cannot be counted\r\n        for (int i = 0; i < topTenUsers.size(); i++) {\r\n            UserScore user = topTenUsers.get(i);\r\n            System.out.printf(\"%4d | %-12s | %5d%n\", i + 1, user.getName(), user.getMarks());\r\n        }\r\n    }\r\n    // Simulated method to retrieve data from the dashboard\r\n    private static List<UserScore> retrieveDataFromDashboard() {\r\n\r\n        // Retrieve the data from the dashboard and populate a list of User objects\r\n        List<UserScore> dashboardData = new ArrayList<>();\r\n\r\n        // Split dashboard de username n score\r\n        // Use for loop / while loop to add username n score into dashboard\r\n        dashboardData.add(new UserScore(\"User123\", 500));\r\n\r\n        return dashboardData;\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Leaderboard.java b/Leaderboard.java
--- a/Leaderboard.java	(revision d6429e63f3352d824f4ae9fe783d4713d9e86804)
+++ b/Leaderboard.java	(date 1684899867044)
@@ -1,55 +1,56 @@
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-
-class UserScore {
-        private String name;
-        private int marks;
-
-        public UserScore(String name, int marks) {
-            this.name = name;
-            this.marks = marks;
-        }
-
-        public String getName() {
-            return name;
-        }
-
-        public int getMarks() {
-            return marks;
-        }
-public class Leaderboard {
-    public static void main(String[] args) {
-        // Retrieve users' names and marks from the dashboard
-        List<UserScore> dashboardData = retrieveDataFromDashboard();
-
-        // Sort the data based on marks in descending order
-        Collections.sort(dashboardData, Comparator.comparingInt(UserScore::getMarks).reversed());
-
-        // Extract the top ten users
-        List<UserScore> topTenUsers = dashboardData.subList(0, Math.min(dashboardData.size(), 10));
-
-        // Display the leaderboard
-        System.out.println("Rank | User         | Marks");
-        System.out.println("-----|--------------|-------");
-        // Add condition if user is disqualified then score cannot be counted
-        for (int i = 0; i < topTenUsers.size(); i++) {
-            UserScore user = topTenUsers.get(i);
-            System.out.printf("%4d | %-12s | %5d%n", i + 1, user.getName(), user.getMarks());
-        }
-    }
-    // Simulated method to retrieve data from the dashboard
-    private static List<UserScore> retrieveDataFromDashboard() {
-
-        // Retrieve the data from the dashboard and populate a list of User objects
-        List<UserScore> dashboardData = new ArrayList<>();
-
-        // Split dashboard de username n score
-        // Use for loop / while loop to add username n score into dashboard
-        dashboardData.add(new UserScore("User123", 500));
-
-        return dashboardData;
-        }
-    }
-}
+//import java.util.ArrayList;
+//import java.util.Collections;
+//import java.util.Comparator;
+//import java.util.List;
+//
+//class UserScore {
+//        private String name;
+//        private int marks;
+//
+//        public UserScore(String name, int marks) {
+//            this.name = name;
+//            this.marks = marks;
+//        }
+//
+//        public String getName() {
+//            return name;
+//        }
+//
+//        public int getMarks() {
+//            return marks;
+//        }
+//
+//public class Leaderboard {
+//    public static void main(String[] args) {
+//        // Retrieve users' names and marks from the dashboard
+//        List<UserScore> dashboardData = retrieveDataFromDashboard();
+//
+//        // Sort the data based on marks in descending order
+//        Collections.sort(dashboardData, Comparator.comparingInt(UserScore::getMarks).reversed());
+//
+//        // Extract the top ten users
+//        List<UserScore> topTenUsers = dashboardData.subList(0, Math.min(dashboardData.size(), 10));
+//
+//        // Display the leaderboard
+//        System.out.println("Rank | User         | Marks");
+//        System.out.println("-----|--------------|-------");
+//        // Add condition if user is disqualified then score cannot be counted
+//        for (int i = 0; i < topTenUsers.size(); i++) {
+//            UserScore user = topTenUsers.get(i);
+//            System.out.printf("%4d | %-12s | %5d%n", i + 1, user.getName(), user.getMarks());
+//        }
+//    }
+//    // Simulated method to retrieve data from the dashboard
+//    private static List<UserScore> retrieveDataFromDashboard() {
+//
+//        // Retrieve the data from the dashboard and populate a list of User objects
+//        List<UserScore> dashboardData = new ArrayList<>();
+//
+//        // Split dashboard de username n score
+//        // Use for loop / while loop to add username n score into dashboard
+//        dashboardData.add(new UserScore("User123", 500));
+//
+//        return dashboardData;
+//        }
+//    }
+//}
